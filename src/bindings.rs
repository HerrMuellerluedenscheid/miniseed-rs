#[doc(hidden)]
/* automatically generated by rust-bindgen */

#[doc(hidden)]
pub const MS_ENDOFFILE: ::std::os::raw::c_uint = 1;
#[doc(hidden)]
pub const MS_NOERROR: ::std::os::raw::c_uint = 0;
#[doc(hidden)]
pub const MS_GENERROR: ::std::os::raw::c_int = -1;
#[doc(hidden)]
pub const MS_NOTSEED: ::std::os::raw::c_int = -2;
#[doc(hidden)]
pub const MS_WRONGLENGTH: ::std::os::raw::c_int = -3;
#[doc(hidden)]
pub const MS_OUTOFRANGE: ::std::os::raw::c_int = -4;
#[doc(hidden)]
pub const MS_UNKNOWNFORMAT: ::std::os::raw::c_int = -5;
#[doc(hidden)]
pub const MS_STBADCOMPFLAG: ::std::os::raw::c_int = -6;
#[doc(hidden)]
pub const HPTMODULUS: ::std::os::raw::c_uint = 1000000;
#[doc(hidden)]
pub const HPTERROR: ::std::os::raw::c_longlong = -2145916800000000;
#[doc(hidden)]
pub type __int64_t = ::std::os::raw::c_longlong;
#[doc(hidden)]
pub type __darwin_off_t = __int64_t;
#[doc(hidden)]
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type FILE = __sFILE;
#[doc(hidden)]
pub type off_t = __darwin_off_t;
#[doc(hidden)]
pub type hptime_t = i64;
#[doc(hidden)]
pub type flag = i8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct btime_s {
    pub year: u16,
    pub day: u16,
    pub hour: u8,
    pub min: u8,
    pub sec: u8,
    pub unused: u8,
    pub fract: u16,
}
#[test]
fn bindgen_test_layout_btime_s() {
    assert_eq!(::std::mem::size_of::<btime_s>() , 10usize , concat ! (
               "Size of: " , stringify ! ( btime_s ) ));
    assert_eq! (::std::mem::align_of::<btime_s>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( btime_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btime_s ) ) . year as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( btime_s ) , "::" ,
                stringify ! ( year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btime_s ) ) . day as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( btime_s ) , "::" ,
                stringify ! ( day ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btime_s ) ) . hour as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( btime_s ) , "::" ,
                stringify ! ( hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btime_s ) ) . min as * const _ as usize }
                , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( btime_s ) , "::" ,
                stringify ! ( min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btime_s ) ) . sec as * const _ as usize }
                , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( btime_s ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btime_s ) ) . unused as * const _ as
                usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( btime_s ) , "::" ,
                stringify ! ( unused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const btime_s ) ) . fract as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( btime_s ) , "::" ,
                stringify ! ( fract ) ));
}
impl Clone for btime_s {
    fn clone(&self) -> Self { *self }
}
pub type BTime = btime_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct fsdh_s {
    pub sequence_number: [::std::os::raw::c_char; 6usize],
    pub dataquality: ::std::os::raw::c_char,
    pub reserved: ::std::os::raw::c_char,
    pub station: [::std::os::raw::c_char; 5usize],
    pub location: [::std::os::raw::c_char; 2usize],
    pub channel: [::std::os::raw::c_char; 3usize],
    pub network: [::std::os::raw::c_char; 2usize],
    pub start_time: BTime,
    pub numsamples: u16,
    pub samprate_fact: i16,
    pub samprate_mult: i16,
    pub act_flags: u8,
    pub io_flags: u8,
    pub dq_flags: u8,
    pub numblockettes: u8,
    pub time_correct: i32,
    pub data_offset: u16,
    pub blockette_offset: u16,
}
#[test]
fn bindgen_test_layout_fsdh_s() {
    assert_eq!(::std::mem::size_of::<fsdh_s>() , 48usize , concat ! (
               "Size of: " , stringify ! ( fsdh_s ) ));
    assert_eq! (::std::mem::align_of::<fsdh_s>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( fsdh_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . sequence_number as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( sequence_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . dataquality as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( dataquality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . reserved as * const _ as
                usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . station as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( station ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . location as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . channel as * const _ as
                usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . network as * const _ as
                usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( network ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . start_time as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( start_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . numsamples as * const _ as
                usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( numsamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . samprate_fact as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( samprate_fact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . samprate_mult as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( samprate_mult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . act_flags as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( act_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . io_flags as * const _ as
                usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( io_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . dq_flags as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( dq_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . numblockettes as * const _
                as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( numblockettes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . time_correct as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( time_correct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . data_offset as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( data_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fsdh_s ) ) . blockette_offset as * const
                _ as usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( fsdh_s ) , "::" ,
                stringify ! ( blockette_offset ) ));
}
impl Clone for fsdh_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct blkt_100_s {
    pub samprate: f32,
    pub flags: i8,
    pub reserved: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_blkt_100_s() {
    assert_eq!(::std::mem::size_of::<blkt_100_s>() , 8usize , concat ! (
               "Size of: " , stringify ! ( blkt_100_s ) ));
    assert_eq! (::std::mem::align_of::<blkt_100_s>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( blkt_100_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_100_s ) ) . samprate as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_100_s ) , "::" ,
                stringify ! ( samprate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_100_s ) ) . flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_100_s ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_100_s ) ) . reserved as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_100_s ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for blkt_100_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct blkt_1000_s {
    pub encoding: u8,
    pub byteorder: u8,
    pub reclen: u8,
    pub reserved: u8,
}
#[test]
fn bindgen_test_layout_blkt_1000_s() {
    assert_eq!(::std::mem::size_of::<blkt_1000_s>() , 4usize , concat ! (
               "Size of: " , stringify ! ( blkt_1000_s ) ));
    assert_eq! (::std::mem::align_of::<blkt_1000_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( blkt_1000_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1000_s ) ) . encoding as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1000_s ) , "::" ,
                stringify ! ( encoding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1000_s ) ) . byteorder as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1000_s ) , "::" ,
                stringify ! ( byteorder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1000_s ) ) . reclen as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1000_s ) , "::" ,
                stringify ! ( reclen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1000_s ) ) . reserved as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1000_s ) , "::" ,
                stringify ! ( reserved ) ));
}
impl Clone for blkt_1000_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct blkt_1001_s {
    pub timing_qual: u8,
    pub usec: i8,
    pub reserved: u8,
    pub framecnt: u8,
}
#[test]
fn bindgen_test_layout_blkt_1001_s() {
    assert_eq!(::std::mem::size_of::<blkt_1001_s>() , 4usize , concat ! (
               "Size of: " , stringify ! ( blkt_1001_s ) ));
    assert_eq! (::std::mem::align_of::<blkt_1001_s>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( blkt_1001_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1001_s ) ) . timing_qual as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1001_s ) , "::" ,
                stringify ! ( timing_qual ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1001_s ) ) . usec as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1001_s ) , "::" ,
                stringify ! ( usec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1001_s ) ) . reserved as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1001_s ) , "::" ,
                stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_1001_s ) ) . framecnt as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_1001_s ) , "::" ,
                stringify ! ( framecnt ) ));
}
impl Clone for blkt_1001_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct blkt_link_s {
    pub blktoffset: u16,
    pub blkt_type: u16,
    pub next_blkt: u16,
    pub blktdata: *mut ::std::os::raw::c_void,
    pub blktdatalen: u16,
    pub next: *mut blkt_link_s,
}
#[test]
fn bindgen_test_layout_blkt_link_s() {
    assert_eq!(::std::mem::size_of::<blkt_link_s>() , 32usize , concat ! (
               "Size of: " , stringify ! ( blkt_link_s ) ));
    assert_eq! (::std::mem::align_of::<blkt_link_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( blkt_link_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_link_s ) ) . blktoffset as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_link_s ) , "::" ,
                stringify ! ( blktoffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_link_s ) ) . blkt_type as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_link_s ) , "::" ,
                stringify ! ( blkt_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_link_s ) ) . next_blkt as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_link_s ) , "::" ,
                stringify ! ( next_blkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_link_s ) ) . blktdata as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_link_s ) , "::" ,
                stringify ! ( blktdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_link_s ) ) . blktdatalen as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_link_s ) , "::" ,
                stringify ! ( blktdatalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const blkt_link_s ) ) . next as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( blkt_link_s ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for blkt_link_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type BlktLink = blkt_link_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct StreamState_s {
    pub packedrecords: i64,
    pub packedsamples: i64,
    pub lastintsample: i32,
    pub comphistory: flag,
}
#[test]
fn bindgen_test_layout_StreamState_s() {
    assert_eq!(::std::mem::size_of::<StreamState_s>() , 24usize , concat ! (
               "Size of: " , stringify ! ( StreamState_s ) ));
    assert_eq! (::std::mem::align_of::<StreamState_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( StreamState_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StreamState_s ) ) . packedrecords as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( StreamState_s ) , "::"
                , stringify ! ( packedrecords ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StreamState_s ) ) . packedsamples as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( StreamState_s ) , "::"
                , stringify ! ( packedsamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StreamState_s ) ) . lastintsample as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( StreamState_s ) , "::"
                , stringify ! ( lastintsample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const StreamState_s ) ) . comphistory as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( StreamState_s ) , "::"
                , stringify ! ( comphistory ) ));
}
impl Clone for StreamState_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type StreamState = StreamState_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct MSRecord_s {
    pub record: *mut ::std::os::raw::c_char,
    pub reclen: i32,
    pub fsdh: *mut fsdh_s,
    pub blkts: *mut BlktLink,
    pub Blkt100: *mut blkt_100_s,
    pub Blkt1000: *mut blkt_1000_s,
    pub Blkt1001: *mut blkt_1001_s,
    pub sequence_number: i32,
    pub network: [::std::os::raw::c_char; 11usize],
    pub station: [::std::os::raw::c_char; 11usize],
    pub location: [::std::os::raw::c_char; 11usize],
    pub channel: [::std::os::raw::c_char; 11usize],
    pub dataquality: ::std::os::raw::c_char,
    pub starttime: hptime_t,
    pub samprate: f64,
    pub samplecnt: i64,
    pub encoding: i8,
    pub byteorder: i8,
    pub datasamples: *mut ::std::os::raw::c_void,
    pub numsamples: i64,
    pub sampletype: ::std::os::raw::c_char,
    pub ststate: *mut StreamState,
}
#[test]
fn bindgen_test_layout_MSRecord_s() {
    assert_eq!(::std::mem::size_of::<MSRecord_s>() , 176usize , concat ! (
               "Size of: " , stringify ! ( MSRecord_s ) ));
    assert_eq! (::std::mem::align_of::<MSRecord_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSRecord_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . record as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( record ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . reclen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( reclen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . fsdh as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( fsdh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . blkts as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( blkts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . Blkt100 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( Blkt100 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . Blkt1000 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( Blkt1000 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . Blkt1001 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( Blkt1001 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . sequence_number as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( sequence_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . network as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( network ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . station as * const _ as
                usize } , 71usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( station ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . location as * const _ as
                usize } , 82usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . channel as * const _ as
                usize } , 93usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . dataquality as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( dataquality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . starttime as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( starttime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . samprate as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( samprate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . samplecnt as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( samplecnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . encoding as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( encoding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . byteorder as * const _
                as usize } , 137usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( byteorder ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . datasamples as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( datasamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . numsamples as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( numsamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . sampletype as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( sampletype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSRecord_s ) ) . ststate as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( MSRecord_s ) , "::" ,
                stringify ! ( ststate ) ));
}
impl Clone for MSRecord_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type MSRecord = MSRecord_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct MSTrace_s {
    pub network: [::std::os::raw::c_char; 11usize],
    pub station: [::std::os::raw::c_char; 11usize],
    pub location: [::std::os::raw::c_char; 11usize],
    pub channel: [::std::os::raw::c_char; 11usize],
    pub dataquality: ::std::os::raw::c_char,
    pub type_: ::std::os::raw::c_char,
    pub starttime: hptime_t,
    pub endtime: hptime_t,
    pub samprate: f64,
    pub samplecnt: i64,
    pub datasamples: *mut ::std::os::raw::c_void,
    pub numsamples: i64,
    pub sampletype: ::std::os::raw::c_char,
    pub prvtptr: *mut ::std::os::raw::c_void,
    pub ststate: *mut StreamState,
    pub next: *mut MSTrace_s,
}
#[test]
fn bindgen_test_layout_MSTrace_s() {
    assert_eq!(::std::mem::size_of::<MSTrace_s>() , 128usize , concat ! (
               "Size of: " , stringify ! ( MSTrace_s ) ));
    assert_eq! (::std::mem::align_of::<MSTrace_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSTrace_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . network as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( network ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . station as * const _ as
                usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( station ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . location as * const _ as
                usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . channel as * const _ as
                usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . dataquality as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( dataquality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . type_ as * const _ as
                usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . starttime as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( starttime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . endtime as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( endtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . samprate as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( samprate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . samplecnt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( samplecnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . datasamples as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( datasamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . numsamples as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( numsamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . sampletype as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( sampletype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . prvtptr as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( prvtptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . ststate as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( ststate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTrace_s ) ) . next as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTrace_s ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for MSTrace_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type MSTrace = MSTrace_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct MSTraceGroup_s {
    pub numtraces: i32,
    pub traces: *mut MSTrace_s,
}
#[test]
fn bindgen_test_layout_MSTraceGroup_s() {
    assert_eq!(::std::mem::size_of::<MSTraceGroup_s>() , 16usize , concat ! (
               "Size of: " , stringify ! ( MSTraceGroup_s ) ));
    assert_eq! (::std::mem::align_of::<MSTraceGroup_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSTraceGroup_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceGroup_s ) ) . numtraces as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceGroup_s ) , "::"
                , stringify ! ( numtraces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceGroup_s ) ) . traces as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceGroup_s ) , "::"
                , stringify ! ( traces ) ));
}
impl Clone for MSTraceGroup_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type MSTraceGroup = MSTraceGroup_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct MSTraceSeg_s {
    pub starttime: hptime_t,
    pub endtime: hptime_t,
    pub samprate: f64,
    pub samplecnt: i64,
    pub datasamples: *mut ::std::os::raw::c_void,
    pub numsamples: i64,
    pub sampletype: ::std::os::raw::c_char,
    pub prvtptr: *mut ::std::os::raw::c_void,
    pub prev: *mut MSTraceSeg_s,
    pub next: *mut MSTraceSeg_s,
}
#[test]
fn bindgen_test_layout_MSTraceSeg_s() {
    assert_eq!(::std::mem::size_of::<MSTraceSeg_s>() , 80usize , concat ! (
               "Size of: " , stringify ! ( MSTraceSeg_s ) ));
    assert_eq! (::std::mem::align_of::<MSTraceSeg_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSTraceSeg_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . starttime as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( starttime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . endtime as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( endtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . samprate as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( samprate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . samplecnt as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( samplecnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . datasamples as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( datasamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . numsamples as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( numsamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . sampletype as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( sampletype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . prvtptr as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( prvtptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . prev as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceSeg_s ) ) . next as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceSeg_s ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for MSTraceSeg_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type MSTraceSeg = MSTraceSeg_s;
#[repr(C)]
#[doc(hidden)]
pub struct MSTraceID_s {
    pub network: [::std::os::raw::c_char; 11usize],
    pub station: [::std::os::raw::c_char; 11usize],
    pub location: [::std::os::raw::c_char; 11usize],
    pub channel: [::std::os::raw::c_char; 11usize],
    pub dataquality: ::std::os::raw::c_char,
    pub srcname: [::std::os::raw::c_char; 45usize],
    pub type_: ::std::os::raw::c_char,
    pub earliest: hptime_t,
    pub latest: hptime_t,
    pub prvtptr: *mut ::std::os::raw::c_void,
    pub numsegments: i32,
    pub first: *mut MSTraceSeg_s,
    pub last: *mut MSTraceSeg_s,
    pub next: *mut MSTraceID_s,
}
#[test]
fn bindgen_test_layout_MSTraceID_s() {
    assert_eq!(::std::mem::size_of::<MSTraceID_s>() , 152usize , concat ! (
               "Size of: " , stringify ! ( MSTraceID_s ) ));
    assert_eq! (::std::mem::align_of::<MSTraceID_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSTraceID_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . network as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( network ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . station as * const _ as
                usize } , 11usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( station ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . location as * const _
                as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . channel as * const _ as
                usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( channel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . dataquality as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( dataquality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . srcname as * const _ as
                usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( srcname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . type_ as * const _ as
                usize } , 90usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . earliest as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( earliest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . latest as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( latest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . prvtptr as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( prvtptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . numsegments as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( numsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . first as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . last as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceID_s ) ) . next as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceID_s ) , "::" ,
                stringify ! ( next ) ));
}
#[doc(hidden)]
pub type MSTraceID = MSTraceID_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct MSTraceList_s {
    pub numtraces: i32,
    pub traces: *mut MSTraceID_s,
    pub last: *mut MSTraceID_s,
}
#[test]
fn bindgen_test_layout_MSTraceList_s() {
    assert_eq!(::std::mem::size_of::<MSTraceList_s>() , 24usize , concat ! (
               "Size of: " , stringify ! ( MSTraceList_s ) ));
    assert_eq! (::std::mem::align_of::<MSTraceList_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSTraceList_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceList_s ) ) . numtraces as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceList_s ) , "::"
                , stringify ! ( numtraces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceList_s ) ) . traces as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceList_s ) , "::"
                , stringify ! ( traces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSTraceList_s ) ) . last as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MSTraceList_s ) , "::"
                , stringify ! ( last ) ));
}
impl Clone for MSTraceList_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type MSTraceList = MSTraceList_s;
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct SelectTime_s {
    pub starttime: hptime_t,
    pub endtime: hptime_t,
    pub next: *mut SelectTime_s,
}
#[test]
fn bindgen_test_layout_SelectTime_s() {
    assert_eq!(::std::mem::size_of::<SelectTime_s>() , 24usize , concat ! (
               "Size of: " , stringify ! ( SelectTime_s ) ));
    assert_eq! (::std::mem::align_of::<SelectTime_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SelectTime_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectTime_s ) ) . starttime as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectTime_s ) , "::" ,
                stringify ! ( starttime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectTime_s ) ) . endtime as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectTime_s ) , "::" ,
                stringify ! ( endtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SelectTime_s ) ) . next as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SelectTime_s ) , "::" ,
                stringify ! ( next ) ));
}
impl Clone for SelectTime_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type SelectTime = SelectTime_s;
#[repr(C)]
#[doc(hidden)]
pub struct Selections_s {
    pub srcname: [::std::os::raw::c_char; 100usize],
    pub timewindows: *mut SelectTime_s,
    pub next: *mut Selections_s,
}
#[test]
fn bindgen_test_layout_Selections_s() {
    assert_eq!(::std::mem::size_of::<Selections_s>() , 120usize , concat ! (
               "Size of: " , stringify ! ( Selections_s ) ));
    assert_eq! (::std::mem::align_of::<Selections_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Selections_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Selections_s ) ) . srcname as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Selections_s ) , "::" ,
                stringify ! ( srcname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Selections_s ) ) . timewindows as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( Selections_s ) , "::" ,
                stringify ! ( timewindows ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Selections_s ) ) . next as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( Selections_s ) , "::" ,
                stringify ! ( next ) ));
}
#[doc(hidden)]
pub type Selections = Selections_s;
extern "C" {
    #[doc(hidden)]
    pub fn msr_parse(record: *mut ::std::os::raw::c_char,
                     recbuflen: ::std::os::raw::c_int,
                     ppmsr: *mut *mut MSRecord, reclen: ::std::os::raw::c_int,
                     dataflag: flag, verbose: flag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_parse_selection(recbuf: *mut ::std::os::raw::c_char,
                               recbuflen: ::std::os::raw::c_int,
                               offset: *mut i64, ppmsr: *mut *mut MSRecord,
                               reclen: ::std::os::raw::c_int,
                               selections: *mut Selections, dataflag: flag,
                               verbose: flag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_unpack(record: *mut ::std::os::raw::c_char,
                      reclen: ::std::os::raw::c_int,
                      ppmsr: *mut *mut MSRecord, dataflag: flag,
                      verbose: flag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_pack(msr: *mut MSRecord,
                    record_handler:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::std::os::raw::c_char,
                                                                   arg2:
                                                                       ::std::os::raw::c_int,
                                                                   arg3:
                                                                       *mut ::std::os::raw::c_void)>,
                    handlerdata: *mut ::std::os::raw::c_void,
                    packedsamples: *mut i64, flush: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_pack_header(msr: *mut MSRecord, normalize: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_unpack_data(msr: *mut MSRecord,
                           swapflag: ::std::os::raw::c_int, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_init(msr: *mut MSRecord) -> *mut MSRecord;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_free(ppmsr: *mut *mut MSRecord);
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_free_blktchain(msr: *mut MSRecord);
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_addblockette(msr: *mut MSRecord,
                            blktdata: *mut ::std::os::raw::c_char,
                            length: ::std::os::raw::c_int,
                            blkttype: ::std::os::raw::c_int,
                            chainpos: ::std::os::raw::c_int) -> *mut BlktLink;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_normalize_header(msr: *mut MSRecord, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_duplicate(msr: *mut MSRecord, datadup: flag) -> *mut MSRecord;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_samprate(msr: *mut MSRecord) -> f64;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_nomsamprate(msr: *mut MSRecord) -> f64;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_starttime(msr: *mut MSRecord) -> hptime_t;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_starttime_uc(msr: *mut MSRecord) -> hptime_t;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_endtime(msr: *mut MSRecord) -> hptime_t;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_srcname(msr: *mut MSRecord,
                       srcname: *mut ::std::os::raw::c_char, quality: flag)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_print(msr: *mut MSRecord, details: flag);
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_host_latency(msr: *mut MSRecord) -> f64;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_detect(record: *const ::std::os::raw::c_char,
                     recbuflen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_parse_raw(record: *mut ::std::os::raw::c_char,
                        maxreclen: ::std::os::raw::c_int, details: flag,
                        swapflag: flag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_init(mst: *mut MSTrace) -> *mut MSTrace;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_free(ppmst: *mut *mut MSTrace);
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_initgroup(mstg: *mut MSTraceGroup) -> *mut MSTraceGroup;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_freegroup(ppmstg: *mut *mut MSTraceGroup);
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_findmatch(startmst: *mut MSTrace,
                         dataquality: ::std::os::raw::c_char,
                         network: *mut ::std::os::raw::c_char,
                         station: *mut ::std::os::raw::c_char,
                         location: *mut ::std::os::raw::c_char,
                         channel: *mut ::std::os::raw::c_char)
     -> *mut MSTrace;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_findadjacent(mstg: *mut MSTraceGroup, whence: *mut flag,
                            dataquality: ::std::os::raw::c_char,
                            network: *mut ::std::os::raw::c_char,
                            station: *mut ::std::os::raw::c_char,
                            location: *mut ::std::os::raw::c_char,
                            channel: *mut ::std::os::raw::c_char,
                            samprate: f64, sampratetol: f64,
                            starttime: hptime_t, endtime: hptime_t,
                            timetol: f64) -> *mut MSTrace;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_addmsr(mst: *mut MSTrace, msr: *mut MSRecord, whence: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_addspan(mst: *mut MSTrace, starttime: hptime_t,
                       endtime: hptime_t,
                       datasamples: *mut ::std::os::raw::c_void,
                       numsamples: i64, sampletype: ::std::os::raw::c_char,
                       whence: flag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_addmsrtogroup(mstg: *mut MSTraceGroup, msr: *mut MSRecord,
                             dataquality: flag, timetol: f64,
                             sampratetol: f64) -> *mut MSTrace;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_addtracetogroup(mstg: *mut MSTraceGroup, mst: *mut MSTrace)
     -> *mut MSTrace;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_groupheal(mstg: *mut MSTraceGroup, timetol: f64,
                         sampratetol: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_groupsort(mstg: *mut MSTraceGroup, quality: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_convertsamples(mst: *mut MSTrace,
                              type_: ::std::os::raw::c_char, truncate: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_srcname(mst: *mut MSTrace,
                       srcname: *mut ::std::os::raw::c_char, quality: flag)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_printtracelist(mstg: *mut MSTraceGroup, timeformat: flag,
                              details: flag, gaps: flag);
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_printsynclist(mstg: *mut MSTraceGroup,
                             dccid: *mut ::std::os::raw::c_char,
                             subsecond: flag);
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_printgaplist(mstg: *mut MSTraceGroup, timeformat: flag,
                            mingap: *mut f64, maxgap: *mut f64);
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_pack(mst: *mut MSTrace,
                    record_handler:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::std::os::raw::c_char,
                                                                   arg2:
                                                                       ::std::os::raw::c_int,
                                                                   arg3:
                                                                       *mut ::std::os::raw::c_void)>,
                    handlerdata: *mut ::std::os::raw::c_void,
                    reclen: ::std::os::raw::c_int, encoding: flag,
                    byteorder: flag, packedsamples: *mut i64, flush: flag,
                    verbose: flag, mstemplate: *mut MSRecord)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_packgroup(mstg: *mut MSTraceGroup,
                         record_handler:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ::std::os::raw::c_char,
                                                                        arg2:
                                                                            ::std::os::raw::c_int,
                                                                        arg3:
                                                                            *mut ::std::os::raw::c_void)>,
                         handlerdata: *mut ::std::os::raw::c_void,
                         reclen: ::std::os::raw::c_int, encoding: flag,
                         byteorder: flag, packedsamples: *mut i64,
                         flush: flag, verbose: flag,
                         mstemplate: *mut MSRecord) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[doc(hidden)]
pub struct MSFileParam_s {
    pub fp: *mut FILE,
    pub filename: [::std::os::raw::c_char; 512usize],
    pub rawrec: *mut ::std::os::raw::c_char,
    pub readlen: ::std::os::raw::c_int,
    pub readoffset: ::std::os::raw::c_int,
    pub packtype: ::std::os::raw::c_int,
    pub packhdroffset: off_t,
    pub filepos: off_t,
    pub filesize: off_t,
    pub recordcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MSFileParam_s() {
    assert_eq!(::std::mem::size_of::<MSFileParam_s>() , 576usize , concat ! (
               "Size of: " , stringify ! ( MSFileParam_s ) ));
    assert_eq! (::std::mem::align_of::<MSFileParam_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSFileParam_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . fp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( fp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . filename as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . rawrec as * const _
                as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( rawrec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . readlen as * const _
                as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( readlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . readoffset as * const
                _ as usize } , 532usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( readoffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . packtype as * const _
                as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( packtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . packhdroffset as *
                const _ as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( packhdroffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . filepos as * const _
                as usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( filepos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . filesize as * const _
                as usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( filesize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSFileParam_s ) ) . recordcount as *
                const _ as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( MSFileParam_s ) , "::"
                , stringify ! ( recordcount ) ));
}
#[doc(hidden)]
pub type MSFileParam = MSFileParam_s;
extern "C" {
    #[doc(hidden)]
    pub fn ms_readmsr(ppmsr: *mut *mut MSRecord,
                      msfile: *const ::std::os::raw::c_char,
                      reclen: ::std::os::raw::c_int, fpos: *mut off_t,
                      last: *mut ::std::os::raw::c_int, skipnotdata: flag,
                      dataflag: flag, verbose: flag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readmsr_r(ppmsfp: *mut *mut MSFileParam,
                        ppmsr: *mut *mut MSRecord,
                        msfile: *const ::std::os::raw::c_char,
                        reclen: ::std::os::raw::c_int, fpos: *mut off_t,
                        last: *mut ::std::os::raw::c_int, skipnotdata: flag,
                        dataflag: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readmsr_main(ppmsfp: *mut *mut MSFileParam,
                           ppmsr: *mut *mut MSRecord,
                           msfile: *const ::std::os::raw::c_char,
                           reclen: ::std::os::raw::c_int, fpos: *mut off_t,
                           last: *mut ::std::os::raw::c_int,
                           skipnotdata: flag, dataflag: flag,
                           selections: *mut Selections, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readtraces(ppmstg: *mut *mut MSTraceGroup,
                         msfile: *const ::std::os::raw::c_char,
                         reclen: ::std::os::raw::c_int, timetol: f64,
                         sampratetol: f64, dataquality: flag,
                         skipnotdata: flag, dataflag: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readtraces_timewin(ppmstg: *mut *mut MSTraceGroup,
                                 msfile: *const ::std::os::raw::c_char,
                                 reclen: ::std::os::raw::c_int, timetol: f64,
                                 sampratetol: f64, starttime: hptime_t,
                                 endtime: hptime_t, dataquality: flag,
                                 skipnotdata: flag, dataflag: flag,
                                 verbose: flag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readtraces_selection(ppmstg: *mut *mut MSTraceGroup,
                                   msfile: *const ::std::os::raw::c_char,
                                   reclen: ::std::os::raw::c_int,
                                   timetol: f64, sampratetol: f64,
                                   selections: *mut Selections,
                                   dataquality: flag, skipnotdata: flag,
                                   dataflag: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readtracelist(ppmstl: *mut *mut MSTraceList,
                            msfile: *const ::std::os::raw::c_char,
                            reclen: ::std::os::raw::c_int, timetol: f64,
                            sampratetol: f64, dataquality: flag,
                            skipnotdata: flag, dataflag: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readtracelist_timewin(ppmstl: *mut *mut MSTraceList,
                                    msfile: *const ::std::os::raw::c_char,
                                    reclen: ::std::os::raw::c_int,
                                    timetol: f64, sampratetol: f64,
                                    starttime: hptime_t, endtime: hptime_t,
                                    dataquality: flag, skipnotdata: flag,
                                    dataflag: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readtracelist_selection(ppmstl: *mut *mut MSTraceList,
                                      msfile: *const ::std::os::raw::c_char,
                                      reclen: ::std::os::raw::c_int,
                                      timetol: f64, sampratetol: f64,
                                      selections: *mut Selections,
                                      dataquality: flag, skipnotdata: flag,
                                      dataflag: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_writemseed(msr: *mut MSRecord,
                          msfile: *const ::std::os::raw::c_char,
                          overwrite: flag, reclen: ::std::os::raw::c_int,
                          encoding: flag, byteorder: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_writemseed(mst: *mut MSTrace,
                          msfile: *const ::std::os::raw::c_char,
                          overwrite: flag, reclen: ::std::os::raw::c_int,
                          encoding: flag, byteorder: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn mst_writemseedgroup(mstg: *mut MSTraceGroup,
                               msfile: *const ::std::os::raw::c_char,
                               overwrite: flag, reclen: ::std::os::raw::c_int,
                               encoding: flag, byteorder: flag, verbose: flag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_recsrcname(record: *mut ::std::os::raw::c_char,
                         srcname: *mut ::std::os::raw::c_char, quality: flag)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_splitsrcname(srcname: *mut ::std::os::raw::c_char,
                           net: *mut ::std::os::raw::c_char,
                           sta: *mut ::std::os::raw::c_char,
                           loc: *mut ::std::os::raw::c_char,
                           chan: *mut ::std::os::raw::c_char,
                           qual: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_strncpclean(dest: *mut ::std::os::raw::c_char,
                          source: *const ::std::os::raw::c_char,
                          length: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_strncpcleantail(dest: *mut ::std::os::raw::c_char,
                              source: *const ::std::os::raw::c_char,
                              length: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_strncpopen(dest: *mut ::std::os::raw::c_char,
                         source: *const ::std::os::raw::c_char,
                         length: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_doy2md(year: ::std::os::raw::c_int, jday: ::std::os::raw::c_int,
                     month: *mut ::std::os::raw::c_int,
                     mday: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_md2doy(year: ::std::os::raw::c_int,
                     month: ::std::os::raw::c_int,
                     mday: ::std::os::raw::c_int,
                     jday: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_btime2hptime(btime: *mut BTime) -> hptime_t;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_btime2isotimestr(btime: *mut BTime,
                               isotimestr: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_btime2mdtimestr(btime: *mut BTime,
                              mdtimestr: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_btime2seedtimestr(btime: *mut BTime,
                                seedtimestr: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_hptime2tomsusecoffset(hptime: hptime_t, toms: *mut hptime_t,
                                    usecoffset: *mut i8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_hptime2btime(hptime: hptime_t, btime: *mut BTime)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_hptime2isotimestr(hptime: hptime_t,
                                isotimestr: *mut ::std::os::raw::c_char,
                                subsecond: flag)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_hptime2mdtimestr(hptime: hptime_t,
                               mdtimestr: *mut ::std::os::raw::c_char,
                               subsecond: flag)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_hptime2seedtimestr(hptime: hptime_t,
                                 seedtimestr: *mut ::std::os::raw::c_char,
                                 subsecond: flag)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_time2hptime(year: ::std::os::raw::c_int,
                          day: ::std::os::raw::c_int,
                          hour: ::std::os::raw::c_int,
                          min: ::std::os::raw::c_int,
                          sec: ::std::os::raw::c_int,
                          usec: ::std::os::raw::c_int) -> hptime_t;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_seedtimestr2hptime(seedtimestr: *mut ::std::os::raw::c_char)
     -> hptime_t;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_timestr2hptime(timestr: *mut ::std::os::raw::c_char)
     -> hptime_t;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_nomsamprate(factor: ::std::os::raw::c_int,
                          multiplier: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_genfactmult(samprate: f64, factor: *mut i16,
                          multiplier: *mut i16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_ratapprox(real: f64, num: *mut ::std::os::raw::c_int,
                        den: *mut ::std::os::raw::c_int,
                        maxval: ::std::os::raw::c_int, precision: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_bigendianhost() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_dabs(val: f64) -> f64;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_rsqrt64(val: f64) -> f64;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_samplesize(sampletype: ::std::os::raw::c_char) -> u8;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_encodingstr(encoding: ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_blktdesc(blkttype: u16) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_blktlen(blkttype: u16, blktdata: *const ::std::os::raw::c_char,
                      swapflag: flag) -> u16;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_errorstr(errorcode: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[doc(hidden)]
#[derive(Debug, Copy)]
pub struct MSLogParam_s {
    pub log_print: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_char)>,
    pub logprefix: *const ::std::os::raw::c_char,
    pub diag_print: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ::std::os::raw::c_char)>,
    pub errprefix: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_MSLogParam_s() {
    assert_eq!(::std::mem::size_of::<MSLogParam_s>() , 32usize , concat ! (
               "Size of: " , stringify ! ( MSLogParam_s ) ));
    assert_eq! (::std::mem::align_of::<MSLogParam_s>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( MSLogParam_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSLogParam_s ) ) . log_print as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( MSLogParam_s ) , "::" ,
                stringify ! ( log_print ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSLogParam_s ) ) . logprefix as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( MSLogParam_s ) , "::" ,
                stringify ! ( logprefix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSLogParam_s ) ) . diag_print as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( MSLogParam_s ) , "::" ,
                stringify ! ( diag_print ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const MSLogParam_s ) ) . errprefix as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( MSLogParam_s ) , "::" ,
                stringify ! ( errprefix ) ));
}
impl Clone for MSLogParam_s {
    fn clone(&self) -> Self { *self }
}
#[doc(hidden)]
pub type MSLogParam = MSLogParam_s;
extern "C" {
    #[doc(hidden)]
    pub fn ms_log(level: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_log_l(logp: *mut MSLogParam, level: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_loginit(log_print:
                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_char)>,
                      logprefix: *const ::std::os::raw::c_char,
                      diag_print:
                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_char)>,
                      errprefix: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_loginit_l(logp: *mut MSLogParam,
                        log_print:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_char)>,
                        logprefix: *const ::std::os::raw::c_char,
                        diag_print:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_char)>,
                        errprefix: *const ::std::os::raw::c_char)
     -> *mut MSLogParam;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_matchselect(selections: *mut Selections,
                          srcname: *mut ::std::os::raw::c_char,
                          starttime: hptime_t, endtime: hptime_t,
                          ppselecttime: *mut *mut SelectTime)
     -> *mut Selections;
}
extern "C" {
    #[doc(hidden)]
    pub fn msr_matchselect(selections: *mut Selections, msr: *mut MSRecord,
                           ppselecttime: *mut *mut SelectTime)
     -> *mut Selections;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_addselect(ppselections: *mut *mut Selections,
                        srcname: *mut ::std::os::raw::c_char,
                        starttime: hptime_t, endtime: hptime_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_addselect_comp(ppselections: *mut *mut Selections,
                             net: *mut ::std::os::raw::c_char,
                             sta: *mut ::std::os::raw::c_char,
                             loc: *mut ::std::os::raw::c_char,
                             chan: *mut ::std::os::raw::c_char,
                             qual: *mut ::std::os::raw::c_char,
                             starttime: hptime_t, endtime: hptime_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readselectionsfile(ppselections: *mut *mut Selections,
                                 filename: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_freeselections(selections: *mut Selections);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_printselections(selections: *mut Selections);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readleapseconds(envvarname: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_readleapsecondfile(filename: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_gswap2(data2: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_gswap3(data3: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_gswap4(data4: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_gswap8(data8: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_gswap2a(data2: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_gswap4a(data4: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc(hidden)]
    pub fn ms_gswap8a(data8: *mut ::std::os::raw::c_void);
}
